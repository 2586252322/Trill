// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class TemporalIngressTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("// *********************************************************************\r\n// Copy" +
                    "right (c) Microsoft Corporation.  All rights reserved.\r\n// Licensed under the MI" +
                    "T License\r\n// ******************************************************************" +
                    "***\r\n/*\\\r\n    * Spec:\r\n    *\r\n    * Apply punctuation policy first. This means t" +
                    "hat even dropped events\r\n    * count towards the number of events seen since the" +
                    " last punctuation.\r\n    * For a Time punctuation policy, insert the punctuation " +
                    "before the\r\n    * event whose start time causes the insertion.\r\n    *\r\n    * Mos" +
                    "t complicated part is the bookkeeping. If the disorder policy is\r\n    * not Thro" +
                    "w, then any events that are dropped or adjusted must be kept\r\n    * track of so " +
                    "that matching end events are dealt with.\r\n    *\r\n    * DisorderPolicy.Throw:\r\n  " +
                    "  *   Don\'t drop any events.\r\n    *\r\n    * DisorderPolicy.Drop:\r\n    *   Start e" +
                    "vent: drop if it is out of order and remember it so corresponding\r\n    *   end e" +
                    "vent is also dropped.\r\n    *   End event: drop if its corresponding start event " +
                    "was dropped or if it is out\r\n    *   of order (latter may leave dangling start e" +
                    "vents that never have an end event).\r\n    *   Interval event: drop if it is out " +
                    "of order\r\n    *   Punctuation event: ??\r\n    *\r\n    * DisorderPolicy.Adjust:\r\n  " +
                    "  *   Start event: if out of order, update start time to start time of previous " +
                    "event.\r\n    *   Remember event so corresponding end event is also modified.\r\n   " +
                    " *   End event: if out of order, update start time to start time of previous eve" +
                    "nt.\r\n    *   If not out of order, check to see if corresponding start event had " +
                    "been modified.\r\n    *   If so, then update its end time to the modified start ti" +
                    "me of the start event.\r\n    *   (This is needed so that its end time matches the" +
                    " start time of the corresponding\r\n    *   start event.)\r\n    *   Interval event:" +
                    " if out of order, update start time to start time of previous event.\r\n    *   If" +
                    " its updated start time is now equal to or greater than its end time, drop it.\r\n" +
                    "\\*/\r\n\r\nusing System;\r\nusing System.Diagnostics.Contracts;\r\nusing System.Diagnost" +
                    "ics;\r\nusing System.Linq.Expressions;\r\nusing System.Runtime.CompilerServices;\r\nus" +
                    "ing System.Runtime.Serialization;\r\nusing Microsoft.StreamProcessing;\r\nusing Micr" +
                    "osoft.StreamProcessing.Internal;\r\nusing Microsoft.StreamProcessing.Internal.Coll" +
                    "ections;\r\n\r\n");
  bool partitioned = (partitionString == "Partitioned");
    string baseStructure = partitionString + "StreamEvent<" + adjustedGenericArgs + ">";
    string globalPunctuation = partitioned ? "LowWatermark" : "Punctuation";
    string highWatermark = partitioned ? "this.partitionHighWatermarks[value.PartitionKey]" : "this.highWatermark";
    string keyType = !partitioned ? "Microsoft.StreamProcessing.Empty" : "PartitionKey<TKey>";
    string streamEventFromValue = fusionOption == "Disordered" ? ("new " + partitionString + "StreamEvent<" + genericArguments + ">(" + (!partitioned ? string.Empty : "value.PartitionKey, ") + "value.SyncTime, value.OtherTime, default)") : "value";

            this.Write("[assembly: IgnoresAccessChecksTo(\"Microsoft.StreamProcessing\")]\r\n[DataContract]\r\n" +
                    "internal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? "Disordered" : string.Empty));
            this.Write("ObserverSubscriptionBase<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyOrNothing));
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n");
  if (partitioned) { 
            this.Write("    private static readonly Func<TKey, int> GetHashCode = EqualityComparerExpress" +
                    "ion<TKey>.DefaultGetHashCodeFunction;\r\n");
  } 
            this.Write("\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IObservable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write("> observable,\r\n        string identifier,\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadOrResult));
            this.Write("> streamable,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadOrResult));
            this.Write("> observer,\r\n        DisorderPolicy disorderPolicy,\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy flushPolicy,\r\n        PeriodicPunctuationPolicy punctuationPolicy,\r\n");
  if (partitioned) { 
            this.Write("        PeriodicLowWatermarkPolicy lowWatermarkPolicy,\r\n");
  } 
            this.Write("        OnCompletedPolicy onCompletedPolicy,\r\n        IObserver<OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(genericArguments));
            this.Write(">> diagnosticOutput)\r\n            : base(observable,\r\n                identifier," +
                    "\r\n                streamable,\r\n                observer,\r\n                disord" +
                    "erPolicy,\r\n                flushPolicy,\r\n                punctuationPolicy,\r\n");
  if (partitioned) { 
            this.Write("                lowWatermarkPolicy,\r\n");
  } 
            this.Write("                onCompletedPolicy,\r\n                diagnosticOutput)\r\n    {\r\n   " +
                    "     ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(" generatedBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(") this.currentBatch;\r\n");
  foreach (var f in this.resultRepresentation.AllFields.Where(fld => fld.OptimizeString()))
    {  
            this.Write("        generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
  } 
            this.Write(@"    }

    [ContractInvariantMethod]
    [System.Diagnostics.CodeAnalysis.SuppressMessage(""Microsoft.Performance"", ""CA1822:MarkMembersAsStatic"", Justification = ""Required for code contracts."")]
    private void ObjectInvariant()
    {
        Contract.Invariant(this.startEventInformation != null);
");
  if (!partitioned)
    { 
            this.Write("        Contract.Invariant(StreamEvent.MinSyncTime <= this.currentTime);\r\n");
  } 
            this.Write("    }\r\n\r\n    protected override void FlushContents()\r\n    {\r\n        base.FlushCo" +
                    "ntents();\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(" generatedBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));
            this.Write(") this.currentBatch;\r\n");
  foreach (var f in this.resultRepresentation.AllFields.Where(fld => fld.OptimizeString()))
    {  
            this.Write("        generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
  } 
            this.Write("    }\r\n\r\n    public override void OnNext(");
            this.Write(this.ToStringHelper.ToStringWithCulture(inheritBase));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ingressType == "StreamEvent" ? "value" : "inputValue"));
            this.Write(")\r\n    {\r\n        Contract.EnsuresOnThrow<IngressException>(true);\r\n");
  if (ingressType == "Interval")
    { 
            this.Write("        var value = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.CreateInterval(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : this.partitionFunction("inputValue") + ", "));
            this.Write(this.ToStringHelper.ToStringWithCulture(this.startEdgeFunction("inputValue")));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.endEdgeFunction("inputValue")));
            this.Write(", inputValue);\r\n");
  }
    if (fusionOption == "Disordered")
    { 
            this.Write(this.ToStringHelper.ToStringWithCulture(leadingText));
            this.Write("\r\n        Action(value.SyncTime, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(generatedEndTimeVariable));
            this.Write(", transformedValue, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? "Microsoft.StreamProcessing.Empty.Default" : "new PartitionKey<TKey>(value.PartitionKey)"));
            this.Write(");\r\n");
            this.Write(this.ToStringHelper.ToStringWithCulture(trailingText));
            this.Write("\r\n    }\r\n\r\n    private void Action(long start, long end, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(" payload, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyType));
            this.Write(" actionKey)\r\n    {\r\n        var value = new ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "TKey, "));
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "actionKey.Key, "));
            this.Write("start, end, payload);\r\n");
  } 
            this.Write("        if (value.Is");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n        {\r\n            GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(value.SyncTime);\r\n            return;\r\n        }\r\n\r\n");
  if (latencyOption == "WithLatency")
    {
        if (partitioned)
        { 
            this.Write("            // Check to see if we need to generate a low watermark due to Periodi" +
                    "cLowWatermarkPolicy\r\n            if (this.lowWatermarkPolicyType == PeriodicLowW" +
                    "atermarkPolicyType.Time &&\r\n                value.SyncTime > this.lowWatermarkTi" +
                    "mestampLag)\r\n            {\r\n                // Generated lowWatermark is always " +
                    "quantized to the last lowWatermarkGenerationPeriod boundary, but\r\n              " +
                    "  // since the last lowWatermark time may have been explicitly ingressed, it is " +
                    "not necessarily quantized,\r\n                // so use the quantized value when c" +
                    "omputing the delta.\r\n                var newLowWatermark = value.SyncTime - this" +
                    ".lowWatermarkTimestampLag;\r\n                if ((ulong)(newLowWatermark - this.l" +
                    "owWatermark.SnapToLeftBoundary((long)this.lowWatermarkGenerationPeriod)) >= this" +
                    ".lowWatermarkGenerationPeriod)\r\n                {\r\n                    // SyncTi" +
                    "me is sufficiently high to generate a new watermark, but first snap it to the ne" +
                    "arest generationPeriod boundary\r\n                    var newLowWatermarkSnapped " +
                    "= newLowWatermark.SnapToLeftBoundary((long)this.lowWatermarkGenerationPeriod);\r\n" +
                    "                    GenerateAndProcessLowWatermark(newLowWatermarkSnapped);\r\n   " +
                    "             }\r\n            }\r\n\r\n        long moveFrom;\r\n        if (!this.curre" +
                    "ntTime.TryGetValue(value.PartitionKey, out moveFrom)) moveFrom = this.lowWaterma" +
                    "rk;\r\n        if (!this.partitionHighWatermarks.ContainsKey(value.PartitionKey))\r" +
                    "\n        {\r\n            this.partitionHighWatermarks.Add(value.PartitionKey, thi" +
                    "s.lowWatermark);\r\n\r\n            if (this.highWatermarkToPartitionsMap.TryGetValu" +
                    "e(this.lowWatermark, out HashSet<TKey> keySet)) keySet.Add(value.PartitionKey);\r" +
                    "\n            else this.highWatermarkToPartitionsMap.Add(this.lowWatermark, new H" +
                    "ashSet<TKey> { value.PartitionKey });\r\n        }\r\n");
      }
        else
        { 
            this.Write("        long moveFrom = this.currentTime;\r\n");
      } 
            this.Write(@"        long moveTo = moveFrom;

        // Events at the reorder boundary or earlier - are handled using default processing policies
        if (value.SyncTime <= moveFrom)
        {
            Process(ref value);
            return;
        }

");
      if (ingressType == "StreamEvent")
        { 
            this.Write("        if (value.IsData)\r\n        {\r\n");
          PushIndent("    ");
        } 
            this.Write("        var oldTime = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(highWatermark));
            this.Write(";\r\n        if (value.SyncTime > oldTime)\r\n        {\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(highWatermark));
            this.Write(" = value.SyncTime;\r\n\r\n");
          if (partitioned)
            { 
            this.Write(@"            var oldSet = this.highWatermarkToPartitionsMap[oldTime];
            if (oldSet.Count <= 1) this.highWatermarkToPartitionsMap.Remove(oldTime);
            else oldSet.Remove(value.PartitionKey);

            if (this.highWatermarkToPartitionsMap.TryGetValue(value.SyncTime, out HashSet<TKey> set)) set.Add(value.PartitionKey);
            else this.highWatermarkToPartitionsMap.Add(value.SyncTime, new HashSet<TKey> { value.PartitionKey });

");
          } 
            this.Write("            moveTo = value.SyncTime - this.reorderLatency;\r\n            if (moveT" +
                    "o < StreamEvent.MinSyncTime) moveTo = StreamEvent.MinSyncTime;\r\n            if (" +
                    "moveTo < moveFrom) moveTo = moveFrom;\r\n            }\r\n");
      if (ingressType == "StreamEvent")
        {
            PopIndent(); 
            this.Write("        }\r\n");
      } 
            this.Write("\r\n        if (moveTo > moveFrom)\r\n        {\r\n            if (this.priorityQueueSo" +
                    "rter != null)\r\n            {\r\n                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(@"> resultEvent;

                while ((!this.priorityQueueSorter.IsEmpty()) && this.priorityQueueSorter.Peek().SyncTime <= moveTo)
                {
                    resultEvent = this.priorityQueueSorter.Dequeue();
                    Process(ref resultEvent");
if (partitioned) {
            this.Write(", updateCurrentTime : false");
}
            this.Write(");\r\n                }\r\n            }\r\n            else\r\n            {\r\n          " +
                    "      // Extract and process data in-order from impatience, until timestamp of m" +
                    "oveTo\r\n                PooledElasticCircularBuffer<");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write("> streamEvents = this.impatienceSorter.DequeueUntil(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write(" moveTo, out bool recheck);\r\n\r\n                if (streamEvents != null)\r\n       " +
                    "         {\r\n                    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(@" resultEvent;
                    while ((streamEvents.Count > 0) && ((!recheck) || (streamEvents.PeekFirst().SyncTime <= moveTo)))
                    {
                        resultEvent = streamEvents.Dequeue();
                        Process(ref resultEvent");
if (partitioned) {
            this.Write(", updateCurrentTime : false");
}
            this.Write(");\r\n                    }\r\n                }\r\n\r\n                if (!recheck && (" +
                    "streamEvents != null))\r\n                    this.impatienceSorter.Return(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write(@" streamEvents);
            }
        }

        if (value.SyncTime == moveTo)
        {
            Process(ref value);
            return;
        }

        // Enqueue value into impatience
        if (this.priorityQueueSorter != null) this.priorityQueueSorter.Enqueue(value);
        else this.impatienceSorter.Enqueue(ref value);

        // Move currentTime forward
");
      if (!partitioned)
        { 
            this.Write("        this.currentTime = moveTo;\r\n");
      }
        else
        { 
            this.Write("        if (!this.currentTime.TryGetValue(value.PartitionKey, out long oldCurrent" +
                    "Time))\r\n            this.currentTime.Add(value.PartitionKey, moveTo);\r\n        e" +
                    "lse if (oldCurrentTime < moveTo)\r\n            this.currentTime[value.PartitionKe" +
                    "y] = moveTo;\r\n");
      } 
            this.Write("        }\r\n\r\n    private void Process(ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(" value");

        if (partitioned)
        {
                
            this.Write(", bool updateCurrentTime = true");

        }       
            this.Write(")\r\n    {\r\n        Contract.EnsuresOnThrow<IngressException>(true);\r\n");
  }

    if (ingressType == "StreamEvent")
    { 
            this.Write("        Contract.Assume(value.SyncTime != value.OtherTime);\r\n\r\n");
  }

    if (ingressType == "StreamEvent" && latencyOption == "WithLatency")
    { 
            this.Write("        if (value.Is");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n        {\r\n            GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(value.SyncTime);\r\n            return;\r\n        }\r\n\r\n");
  }
    if (!partitioned)
    { 
            this.Write("        long current = this.currentTime;\r\n");
  }
    else
    { 
            this.Write(@"        // Update global high water mark if necessary
        this.highWatermark = Math.Max(this.highWatermark, value.SyncTime);

        if (this.punctuationPolicyType == PeriodicPunctuationPolicyType.Time && !this.lastPunctuationTime.ContainsKey(value.PartitionKey))
            this.lastPunctuationTime.Add(value.PartitionKey, this.lowWatermark);

        // Retrieve current time for this partition, updating currentTime if necessary
        long current;
        if (!this.currentTime.TryGetValue(value.PartitionKey, out current))
        {
");
          if (latencyOption == "WithLatency")
            {
            this.Write("            // We should always have a currentTime entry if we are not updating i" +
                    "t\r\n            if (!updateCurrentTime) throw new IngressException(\"Partition exp" +
                    "ected to have a valid currentTime!\");\r\n");
          }
            this.Write("            current = this.lowWatermark;\r\n        }\r\n        else if (");
if (latencyOption == "WithLatency") {
            this.Write("updateCurrentTime && ");
}
            this.Write("current < this.lowWatermark)\r\n        {\r\n            current = this.lowWatermark;" +
                    "\r\n            this.currentTime[value.PartitionKey] = this.lowWatermark;\r\n       " +
                    " }\r\n");
  } 
            this.Write("\r\n        var outOfOrder = value.SyncTime < current;\r\n        if (this.punctuatio" +
                    "nPolicyType == PeriodicPunctuationPolicyType.Time)\r\n        {\r\n");
  if (ingressType == "StreamEvent" && partitioned)
    { 
            this.Write("            // Track punctuation\r\n            if (value.IsPunctuation && value.Sy" +
                    "ncTime > this.lastPunctuationTime[value.PartitionKey])\r\n                this.las" +
                    "tPunctuationTime[value.PartitionKey] = value.SyncTime;\r\n\r\n");
  } 
            this.Write(@"            // out of order events shouldn't count, and if the disorder policy adjusts their sync time, then it
            // will be made equal to a timestamp already seen earlier in the sequence and this would have triggered
            // (if necessary) when that timestamp was seen.
            // Generated punctuation is always quantized to the last generationPeriod boundary, but since the last
            // punctuation time may have been explicitly ingressed, it is not necessarily quantized, so use the
            // quantized value when computing the delta, otherwise, we could produce a punctuation that is before
            // the previous data event.
");
  if (!partitioned)
    { 
            this.Write(@"            ulong delta = (ulong)(value.SyncTime - this.lastPunctuationTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod));
            if (!outOfOrder && delta >= this.punctuationGenerationPeriod)
            {
                // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                var punctuationTimeSnapped = value.SyncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod);
                OnPunctuation(StreamEvent.CreatePunctuation<");
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? TResult : TPayload));
            this.Write(">(punctuationTimeSnapped));\r\n            }\r\n");
  }
    else
    { 
            this.Write(@"            // We use lowWatermark as the baseline in the delta computation because a low watermark implies
            // punctuations for all partitions
            var baselinePunctuationTime = Math.Max(this.lastPunctuationTime[value.PartitionKey], this.lowWatermark);
            var delta = (ulong)(value.SyncTime - baselinePunctuationTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod));
            if (!outOfOrder && this.punctuationGenerationPeriod > 0 && delta >= this.punctuationGenerationPeriod)
            {
                // SyncTime is sufficiently high to generate a new punctuation, but first snap it to the nearest generationPeriod boundary
                var punctuationTimeSnapped = value.SyncTime.SnapToLeftBoundary((long)this.punctuationGenerationPeriod);
                OnPunctuation(PartitionedStreamEvent.CreatePunctuation<TKey, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? TResult : TPayload));
            this.Write(">(value.PartitionKey, punctuationTimeSnapped));\r\n            }\r\n");
  }  
            this.Write("        }\r\n\r\n");
  if (ingressType == "StreamEvent")
    { 
            this.Write("        // check for out of order event\r\n");
      if (partitioned)
        { 
            this.Write("        if (value.IsPunctuation)\r\n        {\r\n            OnPunctuation(value.Crea" +
                    "tePunctuation(outOfOrder ? current : value.SyncTime));\r\n        }\r\n        else\r" +
                    "\n        {\r\n");
              PushIndent("    ");
            }
        } 
            this.Write(@"        if (this.disorderPolicyType == DisorderPolicyType.Throw)
        {
            if (outOfOrder)
            {
                throw new IngressException($""Out-of-order event encountered during ingress, under a disorder policy of Throw: value.SyncTime: {value.SyncTime}, current: {current}"");
            }
        }
        else
        {
");
      if (ingressType == "StreamEvent")
        { 
            this.Write("            // end events and interval events just get dropped\r\n            Tuple" +
                    "<long, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Disordered" ? TResult : TPayload));
            this.Write(@"> key;
            ElasticCircularBuffer<AdjustInfo> q;
            switch (value.Kind)
            {
                case StreamEventKind.Start:
                    if (outOfOrder)
                    {
                        key = Tuple.Create(value.SyncTime, value.Payload);
                        if (!this.startEventInformation.TryGetValue(key, out q))
                        {
                            q = new ElasticCircularBuffer<AdjustInfo>();
                            this.startEventInformation.Add(key, q);
                            var x = new AdjustInfo(current);
                            q.Enqueue(ref x);
                        }
                        else
                        {
                            var last = q.PeekLast();
                            if (last.modifiedStartTime == current) last.numberOfOccurrences++;
                            else
                            {
                                var x = new AdjustInfo(current);
                                q.Enqueue(ref x);
                            }
                        }

                        if (this.disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write("current, StreamEvent.InfinitySyncTime, value.Payload);\r\n                        }" +
                    "\r\n                    }\r\n                    break;\r\n\r\n                case Stre" +
                    "amEventKind.Interval:\r\n");
      } 
            this.Write("                    if (outOfOrder)\r\n                    {\r\n                     " +
                    "   if (this.disorderPolicyType == DisorderPolicyType.Drop)\r\n                    " +
                    "    {\r\n                            this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(@", new long?()));
                            return; // drop
                        }
                        else
                        {
                            if (current >= value.OtherTime)
                            {
                                this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                                return; // drop\r\n              " +
                    "              }\r\n\r\n                            this.diagnosticOutput?.OnNext(Out" +
                    "OfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "value.PartitionKey, "));
            this.Write("current, value.OtherTime, value.Payload);\r\n                        }\r\n           " +
                    "         }\r\n");
      if (ingressType == "StreamEvent")
        { 
            this.Write(@"                    break;

                case StreamEventKind.End:
                    // it may not be out of order, but did we drop/adjust the corresponding start event?
                    key = Tuple.Create(value.OtherTime, value.Payload);
                    if (this.startEventInformation.TryGetValue(key, out q))
                    {
                        Contract.Assume(!q.IsEmpty());
                        var firstElement = q.PeekFirst();
                        firstElement.numberOfOccurrences--;
                        if (firstElement.numberOfOccurrences == 0)
                        {
                            q.Dequeue(); // throw away returned value
                            if (q.Count == 0) this.startEventInformation.Remove(key);
                        }
                        var adjustedTime = firstElement.modifiedStartTime;

                        if (this.disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : ("value.PartitionKey, ")));
            this.Write(@"outOfOrder ? current : value.SyncTime, adjustedTime, value.Payload);
                        }
                    }
                    else if (outOfOrder)
                    {
                        if (this.disorderPolicyType == DisorderPolicyType.Drop)
                        {
                            this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?()));\r\n                            return; // drop\r\n                  " +
                    "      }\r\n                        else\r\n                        {\r\n              " +
                    "              this.diagnosticOutput?.OnNext(OutOfOrder");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.Create(");
            this.Write(this.ToStringHelper.ToStringWithCulture(streamEventFromValue));
            this.Write(", new long?(current - value.SyncTime)));\r\n                            value = new" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(adjustedGenericArgs));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : ("value.PartitionKey, ")));
            this.Write(@"current, value.OtherTime, value.Payload);
                        }
                    }

                    break;
                default:
                    Contract.Assert(false, ""switch meant to be exhaustive"");
                    throw new InvalidOperationException(""Unsupported stream event kind: "" + value.Kind.ToString());
            }
");
      } 
            this.Write("        }\r\n\r\n");
      PushIndent("            "); 
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Fused" ? leadingText : string.Empty));
            this.Write("\r\n");
      AddToGeneratedBatch(); 
            this.Write(this.ToStringHelper.ToStringWithCulture(fusionOption == "Fused" ? trailingText : string.Empty));
            this.Write("\r\n");
      PopIndent(); 
      if (partitioned && ingressType == "StreamEvent")
        {
            PopIndent(); 
            this.Write("        }\r\n");
      } 
            this.Write("\r\n");
      if (!partitioned)
        { 
            this.Write("        if (this.currentTime < value.SyncTime) this.currentTime = value.SyncTime;" +
                    "\r\n");
      }
        else
        { 
            this.Write("        if (!this.currentTime.TryGetValue(value.PartitionKey, out long oldCurrent" +
                    "Time) || oldCurrentTime < value.SyncTime)\r\n            this.currentTime[value.Pa" +
                    "rtitionKey] = value.SyncTime;\r\n");
      } 
            this.Write("    }\r\n\r\n    private void GenerateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(long syncTime)\r\n    {\r\n        if (syncTime <= ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitioned ? "this.lowWatermark" : "this.lastPunctuationTime"));
            this.Write(") return;\r\n\r\n");
      if (!partitioned)
        { 
            this.Write("        \r\n            // Update the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" to be at least the currentTime, so the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("\r\n            // is not before the preceding data event.\r\n");
          if (latencyOption == "WithLatency")
            { 
            this.Write("            // Note that currentTime only reflects events already processed, and " +
                    "excludes events in the reorder buffer.\r\n");
          } 
            this.Write("            syncTime = Math.Max(syncTime, this.currentTime);\r\n");
      } 
            this.Write("\r\n");
      if (latencyOption == "WithLatency")
        { 
            this.Write("        // Process events queued for reorderLatency up to the ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" syncTime\r\n        if (this.priorityQueueSorter != null)\r\n        {\r\n            " +
                    "");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(" resultEvent;\r\n            while ((!this.priorityQueueSorter.IsEmpty()) && this.p" +
                    "riorityQueueSorter.Peek().SyncTime <= syncTime)\r\n            {\r\n                " +
                    "resultEvent = this.priorityQueueSorter.Dequeue();\r\n                Process(ref r" +
                    "esultEvent");
if (partitioned) {
            this.Write(", updateCurrentTime : false");
}
            this.Write(");\r\n            }\r\n        }\r\n        else\r\n        {\r\n");
          if (partitioned)
            { 
            this.Write("            bool recheck;\r\n            var PartitionedstreamEvents = this.impatie" +
                    "nceSorter.DequeueUntil(syncTime);\r\n\r\n            int index = FastDictionary<TKey" +
                    ", Tuple<bool, PooledElasticCircularBuffer<PartitionedStreamEvent<TKey, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">>>>.IteratorStart;\r\n            while(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("streamEvents.Iterate(ref index))\r\n            {\r\n                var entry = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("streamEvents.entries[index];\r\n                recheck = entry.value.Item1;\r\n     " +
                    "           var streamEvents = entry.value.Item2;\r\n");
              PushIndent("    ");
            }
            else
            { 
            this.Write("            var streamEvents = this.impatienceSorter.DequeueUntil(syncTime, out b" +
                    "ool recheck);\r\n");
          } 
            this.Write("            if (streamEvents != null)\r\n            {\r\n                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(baseStructure));
            this.Write(" resultEvent;\r\n                while ((streamEvents.Count > 0) && ((!recheck) || " +
                    "(streamEvents.PeekFirst().SyncTime <= syncTime)))\r\n                {\r\n          " +
                    "          resultEvent = streamEvents.Dequeue();\r\n                    Process(ref" +
                    " resultEvent");
if (partitioned) {
            this.Write(", updateCurrentTime : false");
}
            this.Write(");\r\n                }\r\n                if (!recheck) this.impatienceSorter.Return" +
                    "(");
            this.Write(this.ToStringHelper.ToStringWithCulture(!partitioned ? string.Empty : "entry.key , "));
            this.Write(" streamEvents);\r\n            }\r\n");
          if (partitioned)
            {
                PopIndent(); 
            this.Write("            }\r\n");
          } 
            this.Write("        }\r\n\r\n");
      } 
            this.Write("        // Update cached global times\r\n        this.highWatermark = Math.Max(sync" +
                    "Time, this.highWatermark);\r\n");
      if (partitioned)
        { 
            this.Write(@"        if (this.lowWatermark < syncTime)
        {
            this.lowWatermark = syncTime;

            // Gather keys whose high watermarks are before the new low watermark
            var expiredWatermarkKVPs = new List<KeyValuePair<long, HashSet<TKey>>>();
            foreach (var keyValuePair in this.highWatermarkToPartitionsMap)
            {
                // Since highWatermarkToPartitionsMap is sorted, we can stop as soon as we reach the threshold
                if (keyValuePair.Key >= this.lowWatermark) break;

                expiredWatermarkKVPs.Add(keyValuePair);
            }

            // Clean up state from expired partitions
            foreach (var expiredWatermarkKVP in expiredWatermarkKVPs)
            {
                var expiredWatermark = expiredWatermarkKVP.Key;
                this.highWatermarkToPartitionsMap.Remove(expiredWatermark);

                var expiredKeys = expiredWatermarkKVP.Value;
                foreach (var expiredKey in expiredKeys)
                {
                    this.lastPunctuationTime.Remove(expiredKey);
                    this.partitionHighWatermarks.Remove(expiredKey);
                    this.currentTime.Remove(expiredKey);
                }
            }
        }
");
      }
        else
        { 
            this.Write("        this.currentTime = Math.Max(syncTime, this.currentTime);\r\n        this.la" +
                    "stPunctuationTime = Math.Max(syncTime, this.lastPunctuationTime);\r\n");
      } 
            this.Write("\r\n        // Add ");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" to batch\r\n        var count = this.currentBatch.Count;\r\n        this.currentBatc" +
                    "h.vsync.col[count] = syncTime;\r\n        this.currentBatch.vother.col[count] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(@"OtherTime;
        this.currentBatch.bitvector.col[count >> 6] |= (1L << (count & 0x3f));
        this.currentBatch.key.col[count] = default;
        this.currentBatch[count] = default;
        this.currentBatch.hash.col[count] = 0;
        this.currentBatch.Count = count + 1;

        // Flush if necessary
        if (this.flushPolicy == ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy.FlushOn");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(" ||\r\n            (this.flushPolicy == ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(@"FlushPolicy.FlushOnBatchBoundary && this.currentBatch.Count == Config.DataBatchSize))
        {
            OnFlush();
        }
        else if (this.currentBatch.Count == Config.DataBatchSize)
        {
            FlushContents();
        }
    }

");
      if (partitioned && latencyOption == "WithLatency")
        { 
            this.Write(@"    protected override void UpdatePointers()
    {
        foreach (var kvp in this.partitionHighWatermarks)
        {
            if (this.highWatermarkToPartitionsMap.TryGetValue(kvp.Value, out HashSet<TKey> set))
                set.Add(kvp.Key);
            else
                this.highWatermarkToPartitionsMap.Add(kvp.Value, new HashSet<TKey> { kvp.Key });
        }
    }

");
      } 
            this.Write("    protected override void OnCompleted(long punctuationTime)\r\n    {\r\n        Gen" +
                    "erateAndProcess");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write("(punctuationTime);\r\n        // Flush, but if we just flushed due to the punctuati" +
                    "on generated above\r\n        if (this.flushPolicy != ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("FlushPolicy.FlushOn");
            this.Write(this.ToStringHelper.ToStringWithCulture(globalPunctuation));
            this.Write(")\r\n            OnFlush();\r\n    }\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }

private void AddToGeneratedBatch()
{

this.Write("{\r\n    ");

this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));

this.Write(" generatedBatch = (");

this.Write(this.ToStringHelper.ToStringWithCulture(GeneratedBatchName));

this.Write(") this.currentBatch;\r\n    var count = this.currentBatch.Count;\r\n    this.currentB" +
        "atch.vsync.col[count] = value.SyncTime;\r\n    this.currentBatch.vother.col[count]" +
        " = ");

this.Write(this.ToStringHelper.ToStringWithCulture(generatedEndTimeVariable));

this.Write(";\r\n    this.currentBatch.key.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(emptyOrPartition));

this.Write(";\r\n    this.currentBatch.hash.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(partitionString == "Partitioned" ? "GetHashCode(value.PartitionKey)" : "0"));

this.Write(";\r\n");

 if (resultRepresentation.noFields)
    { 
this.Write("    generatedBatch.payload.col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(";\r\n");

 }
    else
    { 
     if (this.resultMightBeNull)
        { 
this.Write("    if (");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(" == null)\r\n    {\r\n        generatedBatch._nullnessvector.col[count >> 6] |= (1L <" +
        "< (count & 0x3f));\r\n    }\r\n    else\r\n    {\r\n");

         PushIndent("    ");
        } 
     foreach (var f in resultRepresentation.AllFields)
        {
            if (f.OptimizeString())
            { 
this.Write("        generatedBatch.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".AddString(");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));

this.Write(");\r\n");

         }
            else
            { 
this.Write("        generatedBatch.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".col[count] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(valueString));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));

this.Write(";\r\n");

         }
        }
    }  
 if (this.resultMightBeNull)
    {
        PopIndent(); 
this.Write("    }\r\n");

 } 
this.Write("\r\n    this.currentBatch.Count++;\r\n    if (this.currentBatch.Count == Config.DataB" +
        "atchSize)\r\n    {\r\n        if (this.flushPolicy == ");

this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));

this.Write("FlushPolicy.FlushOnBatchBoundary) OnFlush();\r\n        else FlushContents();\r\n    " +
        "}\r\n}\r\n");


}

    }
}
